#!/usr/bin/env python3
"""
uQCme - Microbial Quality Control Web Application

A Streamlit web application for visualizing and exploring microbial QC results
generated by the uQCme CLI tool. This module focuses on data tables and
interactive data exploration, with plotting functionality handled by plot.py.
"""

import streamlit as st
import pandas as pd
import yaml
from pathlib import Path
from typing import Dict, Any, Optional
from plot import QCPlotter, get_available_metrics


class QCDashboard:
    """Main class for the QC dashboard application."""

    def __init__(self, config_path: str):
        """Initialize the dashboard with configuration."""
        self.config = self._load_config(config_path)
        self.data: pd.DataFrame = pd.DataFrame()
        self.mapping: Dict[str, Any] = {}
        self.qc_rules: pd.DataFrame = pd.DataFrame()
        self.qc_tests: pd.DataFrame = pd.DataFrame()
        self.plotter: QCPlotter = QCPlotter(self.config)
        
    def _load_config(self, config_path: str) -> Dict[str, Any]:
        """Load configuration from YAML file."""
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                return yaml.safe_load(f)
        except Exception as e:
            st.error(f"Error loading config: {e}")
            st.stop()

    def _get_dashboard_config(self, key: str, default_value):
        """Get dashboard configuration value with fallback to default."""
        dashboard_config = self.config.get('app', {}).get('dashboard', {})
        return dashboard_config.get(key, default_value)

    def load_data(self):
        """Load all required data files."""
        try:
            # Load processed QC results
            data_path = self.config['app']['input']['data']
            self.data = pd.read_csv(data_path, sep='\t')
            
            # Load mapping configuration
            mapping_path = self.config['app']['input']['mapping']
            with open(mapping_path, 'r', encoding='utf-8') as f:
                self.mapping = yaml.safe_load(f)
            
            # Load QC rules
            rules_path = self.config['app']['input']['qc_rules']
            self.qc_rules = pd.read_csv(rules_path, sep='\t')
            
            # Load QC tests
            tests_path = self.config['app']['input']['qc_tests']
            self.qc_tests = pd.read_csv(tests_path, sep='\t')
            
        except Exception as e:
            st.error(f"Error loading data: {e}")
            st.stop()

    def setup_page(self):
        """Set up the Streamlit page configuration."""
        st.set_page_config(
            page_title=self.config.get('title', 'uQCme Dashboard'),
            page_icon="ğŸ”¬",
            layout="wide",
            initial_sidebar_state="expanded"
        )

    def render_header(self):
        """Render the application header."""
        st.title("ğŸ”¬ uQCme - Microbial Quality Control Dashboard")
    
    def render_sidebar_metrics(self, filtered_data: pd.DataFrame):
        """Render summary metrics in the sidebar."""
        st.sidebar.markdown("---")
        st.sidebar.subheader("ğŸ“Š Summary")
        
        # Version info
        version = self.config.get('version', 'Unknown')
        st.sidebar.markdown(f"**Version:** {version}")
        
        # Sample count metrics
        total_samples = len(filtered_data)
        total_all = len(self.data)
        st.sidebar.metric("Samples", total_samples, delta=f"of {total_all}")
        
        # QC outcome metrics
        pass_filter = filtered_data['qc_outcome'] == 'PASS'
        pass_count = len(filtered_data[pass_filter])
        st.sidebar.metric("PASS", pass_count)
        
        fail_filter = filtered_data['qc_outcome'] != 'PASS'
        fail_count = len(filtered_data[fail_filter])
        st.sidebar.metric("Issues Found", fail_count)

    def _get_filterable_fields(self, data: pd.DataFrame) -> list:
        """Get all fields that should have filters based on mapping config."""
        filterable_fields = []
        sections_columns = self._get_columns_by_section(data)
        
        for section_name, section_cols in sections_columns.items():
            for col_info in section_cols:
                if col_info['filter'] and col_info['column'] in data.columns:
                    filterable_fields.append({
                        'column': col_info['column'],
                        'field_name': col_info['field_name'],
                        'section': section_name
                    })
        
        return filterable_fields

    def _create_numerical_filter(self, filtered_data: pd.DataFrame,
                                 column: str, field_name: str) -> pd.DataFrame:
        """Create and apply numerical range filter."""
        unique_values = filtered_data[column].dropna()
        
        if len(unique_values) == 0:
            return filtered_data
            
        min_val = float(unique_values.min())
        max_val = float(unique_values.max())
        
        # Only show slider if there's a range
        if min_val == max_val:
            return filtered_data
            
        selected_range = st.sidebar.slider(
            f"{field_name} Range",
            min_value=min_val,
            max_value=max_val,
            value=(min_val, max_val),
            key=f"range_{column}"
        )
        
        # Apply range filter
        # Include NaN values when slider is at full range
        full_range = (selected_range[0] == min_val and
                      selected_range[1] == max_val)
        if full_range:
            # Full range selected - don't filter anything
            return filtered_data
        else:
            # Partial range - apply filter but preserve NaN
            col_data = filtered_data[column]
            min_check = col_data >= selected_range[0]
            max_check = col_data <= selected_range[1]
            in_range = min_check & max_check
            range_condition = (in_range | col_data.isna())
            return filtered_data[range_condition]

    def _create_categorical_filter(self, filtered_data: pd.DataFrame,
                                   column: str,
                                   field_name: str) -> pd.DataFrame:
        """Create and apply categorical dropdown filter."""
        unique_values = filtered_data[column].dropna()
        
        if len(unique_values) == 0:
            return filtered_data
            
        unique_sorted = sorted(unique_values.unique())
        
        # Only create filter if we have reasonable number of options
        threshold = self._get_dashboard_config(
            'categorical_filter_threshold', 20
        )
        if len(unique_sorted) > threshold:
            return filtered_data
            
        options = ['All'] + list(unique_sorted)
        selected_value = st.sidebar.selectbox(
            f"Filter by {field_name}",
            options,
            index=0,
            key=f"filter_{column}"
        )
        
        if selected_value != 'All':
            filter_condition = (filtered_data[column] == selected_value)
            return filtered_data[filter_condition]
        
        return filtered_data

    def _create_text_search_filter(self, filtered_data: pd.DataFrame,
                                   column: str,
                                   field_name: str) -> pd.DataFrame:
        """Create and apply text search filter."""
        search_value = st.sidebar.text_input(
            f"Search {field_name}",
            placeholder=f"Enter {field_name.lower()}...",
            key=f"search_{column}"
        )
        
        if search_value:
            column_str = filtered_data[column].astype(str)
            contains_filter = column_str.str.contains(
                search_value, case=False, na=False
            )
            return filtered_data[contains_filter]
        
        return filtered_data

    def render_sidebar_filters(self):
        """Render sidebar filters for data exploration."""
        st.sidebar.header("ğŸ” Filters")
        
        # Get filterable fields from mapping configuration
        filterable_fields = self._get_filterable_fields(self.data)
        
        # Apply filters
        filtered_data = self.data.copy()
        
        # Generate dynamic filters based on mapping configuration
        for field_info in filterable_fields:
            column = field_info['column']
            field_name = field_info['field_name']
            
            if column in filtered_data.columns:
                # Get unique values for this column
                unique_values = filtered_data[column].dropna()
                
                if len(unique_values) > 0:
                    # Check if column is numerical
                    is_numeric = pd.api.types.is_numeric_dtype(unique_values)
                    
                    if is_numeric:
                        # Use extracted numerical filter method
                        filtered_data = self._create_numerical_filter(
                            filtered_data, column, field_name
                        )
                    else:
                        # Categorical or text filters for non-numerical columns
                        unique_sorted = sorted(unique_values.unique())
                        
                        # Determine filter type based on unique count
                        threshold = self._get_dashboard_config(
                            'categorical_filter_threshold', 20
                        )
                        if len(unique_sorted) <= threshold:
                            # Use extracted categorical filter method
                            filtered_data = self._create_categorical_filter(
                                filtered_data, column, field_name
                            )
                        else:
                            # Use extracted text search filter method
                            filtered_data = self._create_text_search_filter(
                                filtered_data, column, field_name
                            )
        
        # Add sample name search (always available)
        sample_filter = st.sidebar.text_input(
            "Search Sample Names",
            placeholder="Enter sample name...",
            key="search_sample_name"
        )
        
        if sample_filter:
            contains_filter = filtered_data['sample_name'].str.contains(
                sample_filter, case=False, na=False
            )
            filtered_data = filtered_data[contains_filter]
        
        # Render summary metrics in sidebar after filters
        self.render_sidebar_metrics(filtered_data)
        
        return filtered_data

    def _get_columns_by_section(self, data: pd.DataFrame) -> Dict[str, list]:
        """Get columns organized by section from mapping.yaml."""
        sections_columns = {}
        
        # Get sections from mapping
        sections = self.mapping.get('Sections', {})
        
        for section_name, section_data in sections.items():
            section_cols = []
            
            for field_name, field_config in section_data.items():
                # Skip if field_config is not a dict (e.g., boolean values)
                if not isinstance(field_config, dict):
                    continue
                    
                mapping_key = field_config.get('data', {}).get('mapping')
                if mapping_key and mapping_key in data.columns:
                    # Get report configuration
                    report_config = field_config.get('report', {})
                    
                    # Include hidden fields in the section but mark them
                    is_hidden = (field_config.get('hidden', False) or
                                 report_config.get('hidden', False))
                    
                    section_cols.append({
                        'column': mapping_key,
                        'field_name': field_name,
                        'hidden': is_hidden,
                        'filter': report_config.get('filter', False),
                        'id': report_config.get('id', False)
                    })
            
            if section_cols:  # Only add sections that have columns
                sections_columns[section_name] = section_cols
        
        # Add unmapped columns to "Other" section
        all_mapped_cols = []
        for section_cols in sections_columns.values():
            all_mapped_cols.extend([col['column'] for col in section_cols])
        
        unmapped_cols = [
            col for col in data.columns
            if col not in all_mapped_cols
        ]
        
        if unmapped_cols:
            sections_columns['Other'] = [
                {
                    'column': col,
                    'field_name': col.replace('_', ' ').title(),
                    'hidden': False,
                    'filter': False,
                    'id': False
                }
                for col in unmapped_cols
            ]
        
        return sections_columns

    def _get_id_column(self, data: pd.DataFrame) -> Optional[str]:
        """Get the column marked as ID field in mapping configuration."""
        sections_columns = self._get_columns_by_section(data)
        
        for section_cols in sections_columns.values():
            for col_info in section_cols:
                if col_info.get('id', False):
                    return col_info['column']
        
        return None

    def _get_ordered_columns_with_sections(
        self,
        data: pd.DataFrame,
        visible_sections: Dict[str, bool]
    ) -> list:
        """Get ordered columns based on visible sections."""
        ordered_cols = []
        sections_columns = self._get_columns_by_section(data)
        
        # Define section order
        section_order = ['Basic', 'QC_metrics', 'Experimental', 'Other']
        
        # Add columns from visible sections in order
        for section_name in section_order:
            section_visible = visible_sections.get(section_name, True)
            if section_name in sections_columns and section_visible:
                for col_info in sections_columns[section_name]:
                    # Skip hidden fields
                    if col_info['hidden']:
                        continue
                    ordered_cols.append(col_info['column'])
        
        # Add remaining sections not in the predefined order
        for section_name, section_cols in sections_columns.items():
            section_visible = visible_sections.get(section_name, True)
            section_not_ordered = section_name not in section_order
            if section_not_ordered and section_visible:
                for col_info in section_cols:
                    if col_info['column'] not in ordered_cols:
                        ordered_cols.append(col_info['column'])
        
        return ordered_cols

    def _get_qc_outcome_priority(self, outcome: str) -> int:
        """Get priority level for QC outcome."""
        # Get outcome priority mapping from config, with fallback defaults
        config_priorities = self.config.get('outcome_priorities', {})
        
        # Default outcome priority mapping (higher number = higher priority)
        default_priorities = {
            'PASS': 1,
            'WARNING': 2,
            'FAIL': 3,
            'ERROR': 4
        }
        
        # Use config priority if available, otherwise use default
        outcome_upper = outcome.upper()
        if outcome_upper in config_priorities:
            return config_priorities[outcome_upper]
        else:
            return default_priorities.get(outcome_upper, 4)

    def _get_qc_outcome_color(self, outcome: str) -> str:
        """Get color for QC outcome based on priority."""
        priority = self._get_qc_outcome_priority(outcome)
        priority_colors = self.config.get('priority_colors', {})
        
        # Default color mapping as fallback (darker text-friendly colors)
        default_color_mapping = {
            1: "#00AA00",  # Dark green for PASS
            2: "#FF8C00",  # Dark orange for WARNING
            3: "#DC143C",  # Dark red for FAIL
            4: "#8B0000"   # Dark red for ERROR
        }
        
        # Use config color if available, otherwise use default mapping
        if priority in priority_colors:
            return priority_colors[priority]
        else:
            return default_color_mapping.get(priority, "#000000")

    def _render_plotly_chart(self, fig, key: str, title: Optional[str] = None):
        """Helper method to render plotly charts with consistent styling."""
        if title:
            st.subheader(title)
        if fig:
            st.plotly_chart(
                fig,
                use_container_width=True,
                key=key
            )

    def _render_styled_dataframe(self, filtered_data: pd.DataFrame,
                                 column_order: list, key: str):
        """Helper method to render dataframe with QC styling and selection."""
        # Initialize session state for selected samples
        if 'selected_samples' not in st.session_state:
            st.session_state.selected_samples = set()
        
        # Get the ID column for sample selection
        id_column = self._get_id_column(filtered_data)
        
        # Create a working copy of the data
        display_data = filtered_data.copy()
        
        # Add selection checkbox column if ID column exists
        if id_column and id_column in filtered_data.columns:
            # Add a checkbox column for selection
            display_data['Select'] = display_data[id_column].apply(
                lambda x: x in st.session_state.selected_samples
            )
            # Put the select column first
            column_order = ['Select'] + column_order
        
        # Configure columns
        column_config = {}
        
        # Configure the select column if present
        if 'Select' in display_data.columns:
            column_config['Select'] = st.column_config.CheckboxColumn(
                "Select",
                help="Select this sample"
            )
        
        # Apply QC outcome styling using pandas styler if column exists
        if 'qc_outcome' in display_data.columns:
            def highlight_qc_outcome(val):
                if pd.isna(val):
                    return ''
                color = self._get_qc_outcome_color(str(val))
                return (f'color: {color}; font-weight: bold; '
                        f'text-shadow: 0 0 3px {color};')
            
            styled_data = display_data.style.map(
                highlight_qc_outcome,
                subset=['qc_outcome']
            )
        else:
            styled_data = display_data
        
        # Disable all columns except Select to prevent accidental editing
        disabled_columns = [col for col in display_data.columns
                            if col != 'Select']
        
        # Use data_editor to enable checkbox interaction
        edited_data = st.data_editor(
            styled_data,
            use_container_width=True,
            key=key,
            column_order=column_order,
            column_config=column_config,
            hide_index=True,
            disabled=disabled_columns
        )
        
        # Update selected samples based on checkbox changes
        if 'Select' in edited_data.columns and id_column:
            # Get current selections from the edited data
            current_selections = set()
            for idx, row in edited_data.iterrows():
                if row['Select']:
                    sample_id = str(row[id_column])
                    current_selections.add(sample_id)
            
            # Update session state if there are changes
            if current_selections != st.session_state.selected_samples:
                st.session_state.selected_samples = current_selections
                st.rerun()
        
        # Display selected samples summary
        if st.session_state.selected_samples:
            selected_samples = sorted(st.session_state.selected_samples)
            selected_text = ', '.join(selected_samples)
            st.info(f"**Selected samples:** {selected_text}")
            
            if st.button("Clear Selection", key=f"clear_{key}"):
                st.session_state.selected_samples.clear()
                st.rerun()

    def render_data_tab(self, filtered_data: pd.DataFrame):
        """Render the data tab with section toggles."""
        st.header("ğŸ“Š Data")
        
        sample_count = len(filtered_data)
        total_count = len(self.data)
        st.write(f"**Showing {sample_count} of {total_count} samples**")
        
        # Section toggles
        st.subheader("Section Visibility")
        sections_columns = self._get_columns_by_section(filtered_data)
        
        # Create columns for section toggles
        num_columns = self._get_dashboard_config('section_toggle_columns', 3)
        toggle_columns = st.columns(num_columns)
        
        visible_sections = {}
        section_names = list(sections_columns.keys())
        
        # Distribute toggles across columns
        for i, section_name in enumerate(section_names):
            col_idx = i % num_columns
            
            with toggle_columns[col_idx]:
                # Count visible columns in section
                section_cols = sections_columns[section_name]
                visible_col_count = len([
                    col for col in section_cols
                    if not col['hidden']
                ])
                
                # Default visibility based on content
                # Hide sections that are mostly hidden fields or experimental
                default_visible = True
                if visible_col_count == 0:
                    default_visible = False
                
                visible_sections[section_name] = st.checkbox(
                    f"{section_name} ({visible_col_count} columns)",
                    value=default_visible,
                    key=f"data_preview_toggle_{section_name}"
                )
        
        # Get ordered columns based on visible sections for reference
        ordered_columns = self._get_ordered_columns_with_sections(
            filtered_data,
            visible_sections
        )
        
        # Show active sections info
        active_sections = [
            name for name, visible in visible_sections.items()
            if visible
        ]
        
        # Display helpful info about column organization
        if ordered_columns:
            tip_msg = (
                f"ğŸ’¡ **Tip:** Use the column visibility controls (ğŸ‘ï¸) in the "
                f"table to show/hide specific columns. Currently showing "
                f"{len(ordered_columns)} columns from selected sections: "
                f"{', '.join(active_sections)}"
            )
            st.info(tip_msg)
        
        # Reorder dataframe columns to put important ones first
        # while preserving all columns for eyeball functionality
        priority_columns = []
        other_columns = []
        
        # Add columns in section order priority
        for col in ordered_columns:
            if col in filtered_data.columns:
                priority_columns.append(col)
        
        # Add remaining columns
        for col in filtered_data.columns:
            if col not in priority_columns:
                other_columns.append(col)
        
        # Create column order for Streamlit's column_order parameter
        column_order = priority_columns + other_columns
        
        # Display the dataframe with built-in controls and QC outcome styling
        # Use the full filtered data to ensure column controls are available
        self._render_styled_dataframe(
            filtered_data, column_order, "data_preview_table"
        )
        
        # Show column information organized by visible sections
        with st.expander("ğŸ“‹ Column Information"):
            st.write("**Column mapping from configuration:**")
            
            for section_name in active_sections:
                if section_name in sections_columns:
                    st.subheader(f"{section_name} Section")
                    section_cols = sections_columns[section_name]
                    
                    for col_info in section_cols:
                        mapping_key = col_info['column']
                        field_name = col_info['field_name']
                        hidden = col_info['hidden']
                        has_filter = col_info['filter']
                        is_id = col_info['id']
                        
                        if mapping_key in filtered_data.columns:
                            # Skip hidden fields from display
                            if hidden:
                                continue
                                
                            # Build display string with additional info
                            extras = []
                            if has_filter:
                                extras.append("Filterable")
                            if is_id:
                                extras.append("ID")
                            
                            extra_info = ""
                            if extras:
                                extra_info = f" ({', '.join(extras)})"
                            
                            field_display = (
                                f"- **{field_name}**: `{mapping_key}`"
                                f"{extra_info}"
                            )
                            st.write(field_display)

    def render_overview_tab(self, filtered_data: pd.DataFrame):
        """Render the overview tab with summary statistics."""
        st.header("ğŸ“ˆ Overview")
        
        # Use the plotter to create overview charts
        overview_plots = self.plotter.create_quality_overview_dashboard(
            filtered_data
        )
        
        # Display charts in columns
        col1, col2 = st.columns(2)
        
        with col1:
            self._render_plotly_chart(
                overview_plots.get('outcome_pie'),
                "overview_outcome_pie",
                "QC Outcomes Distribution"
            )
        
        with col2:
            self._render_plotly_chart(
                overview_plots.get('species_bar'),
                "overview_species_bar",
                "Species Distribution"
            )
        
        # Failed Rules Analysis
        self._render_plotly_chart(
            overview_plots.get('failed_rules'),
            "overview_failed_rules",
            "Most Common Failed Rules"
        )
        
        # Quality metrics if available
        self._render_plotly_chart(
            overview_plots.get('metric_dist'),
            "overview_metric_dist",
            "Quality Metrics Distribution"
        )
        
        self._render_plotly_chart(
            overview_plots.get('correlation'),
            "overview_correlation",
            "Metrics Correlation"
        )

    def render_quality_metrics_tab(self, filtered_data: pd.DataFrame):
        """Render quality metrics visualizations."""
        st.header("ğŸ” Quality Metrics")
        
        # Get available numeric columns
        available_cols = get_available_metrics(filtered_data)
        
        if not available_cols:
            warning_msg = (
                "No numeric quality metrics available for visualization."
            )
            st.warning(warning_msg)
            return
        
        # Metrics selection
        col1, col2 = st.columns(2)
        
        with col1:
            selected_metric = st.selectbox(
                "Select Quality Metric",
                available_cols,
                format_func=lambda x: self.plotter._format_column_name(x),
                index=0
            )
        
        with col2:
            chart_type = st.selectbox(
                "Chart Type",
                ["Distribution", "Box Plot", "Scatter Plot"],
                index=0
            )
        
        # Create visualizations using plotter
        if selected_metric and chart_type:
            if chart_type == "Distribution":
                fig = self.plotter.create_distribution_plot(
                    filtered_data, selected_metric
                )
                self._render_plotly_chart(fig, "metrics_distribution")
                
            elif chart_type == "Box Plot":
                fig = self.plotter.create_box_plot(
                    filtered_data, selected_metric
                )
                self._render_plotly_chart(fig, "metrics_box_plot")
                
            elif chart_type == "Scatter Plot":
                # Find another metric for comparison
                other_metrics = [
                    col for col in available_cols
                    if col != selected_metric
                ]
                
                if other_metrics:
                    def format_metric_name(x):
                        return self.plotter._format_column_name(x)
                    
                    y_metric = st.selectbox(
                        "Select Y-axis metric",
                        other_metrics,
                        format_func=format_metric_name,
                        index=0
                    )
                    
                    if y_metric:
                        fig = self.plotter.create_scatter_plot(
                            filtered_data, selected_metric, y_metric
                        )
                        self._render_plotly_chart(fig, "metrics_scatter_plot")
                else:
                    warning_msg = (
                        "No additional metrics available for scatter plot."
                    )
                    st.warning(warning_msg)

    def render_sample_details_tab(self, filtered_data: pd.DataFrame):
        """Render detailed sample information."""
        st.header("ğŸ”¬ Sample Details")
        
        # Sample selection
        sample_options = filtered_data['sample_name'].tolist()
        
        if not sample_options:
            st.warning("No samples match the current filters.")
            return
        
        selected_sample = st.selectbox(
            "Select Sample",
            sample_options
        )
        
        # Get sample data
        selected_filter = filtered_data['sample_name'] == selected_sample
        sample_data = filtered_data[selected_filter].iloc[0]
        
        # Display sample information
        col1, col2 = st.columns(2)
        
        with col1:
            st.subheader("Basic Information")
            st.write(f"**Sample Name:** {sample_data['sample_name']}")
            st.write(f"**Species:** {sample_data['species']}")
            provided_spec = sample_data.get('provided_species', 'N/A')
            st.write(f"**Provided Species:** {provided_spec}")
            st.write(f"**QC Outcome:** {sample_data['qc_outcome']}")
        
        with col2:
            st.subheader("Quality Metrics")
            if 'GC' in sample_data:
                st.write(f"**GC Content:** {sample_data['GC']:.2f}%")
            if 'N50' in sample_data:
                st.write(f"**N50:** {sample_data['N50']:,.0f}")
            if 'bin_length_at_1x' in sample_data:
                genome_size = sample_data['bin_length_at_1x']
                st.write(f"**Genome Size:** {genome_size:,.0f} bp")
        
        # Failed and passed rules
        st.subheader("QC Rules Analysis")
        
        col1, col2 = st.columns(2)
        
        with col1:
            if sample_data.get('failed_rules'):
                st.write("**Failed Rules:**")
                failed_rules = sample_data['failed_rules'].split(',')
                for rule in failed_rules:
                    st.write(f"âŒ {rule.strip()}")
            else:
                st.write("âœ… No failed rules")
        
        with col2:
            if sample_data.get('passed_rules'):
                st.write("**Passed Rules:**")
                passed_rules = sample_data['passed_rules'].split(',')
                max_rules = self._get_dashboard_config(
                    'max_displayed_rules', 10
                )
                for rule in passed_rules[:max_rules]:
                    st.write(f"âœ… {rule.strip()}")
                if len(passed_rules) > max_rules:
                    remaining = len(passed_rules) - max_rules
                    st.write(f"... and {remaining} more")

    def run(self):
        """Run the Streamlit application."""
        # Setup page
        self.setup_page()
        
        # Load data
        self.load_data()
        
        # Render header (without metrics now)
        self.render_header()
        
        # Get filtered data (this will also render sidebar metrics)
        filtered_data = self.render_sidebar_filters()
        
        # Main content tabs
        tabs = st.tabs([
            "ğŸ“Š Data Preview",
            "ğŸ“ˆ Overview",
            "ğŸ” Quality Metrics",
            "ğŸ”¬ Sample Details"
        ])
        
        with tabs[0]:
            self.render_data_tab(filtered_data)
        
        with tabs[1]:
            self.render_overview_tab(filtered_data)
        
        with tabs[2]:
            self.render_quality_metrics_tab(filtered_data)
        
        with tabs[3]:
            self.render_sample_details_tab(filtered_data)


def main():
    """Main entry point for the Streamlit app."""
    # Configuration file path
    config_path = "config.yaml"
    
    # Check if config file exists
    if not Path(config_path).exists():
        st.error(f"Configuration file '{config_path}' not found!")
        st.stop()
    
    # Initialize and run dashboard
    dashboard = QCDashboard(config_path)
    dashboard.run()


if __name__ == "__main__":
    main()
