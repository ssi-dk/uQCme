#!/usr/bin/env python3
"""
uQCme - Microbial Quality Control Web Application

A Streamlit web application for visualizing and exploring microbial QC results
generated by the uQCme CLI tool. This module focuses on data tables and
interactive data exploration, with plotting functionality handled by plot.py.
"""

import streamlit as st
import pandas as pd
import yaml
from pathlib import Path
from typing import Dict, Any
from plot import QCPlotter, get_available_metrics


class QCDashboard:
    """Main class for the QC dashboard application."""

    def __init__(self, config_path: str):
        """Initialize the dashboard with configuration."""
        self.config = self._load_config(config_path)
        self.data: pd.DataFrame = pd.DataFrame()
        self.mapping: Dict[str, Any] = {}
        self.qc_rules: pd.DataFrame = pd.DataFrame()
        self.qc_tests: pd.DataFrame = pd.DataFrame()
        self.plotter: QCPlotter = QCPlotter(self.config)
        
    def _load_config(self, config_path: str) -> Dict[str, Any]:
        """Load configuration from YAML file."""
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                return yaml.safe_load(f)
        except Exception as e:
            st.error(f"Error loading config: {e}")
            st.stop()

    def load_data(self):
        """Load all required data files."""
        try:
            # Load processed QC results
            data_path = self.config['app']['input']['data']
            self.data = pd.read_csv(data_path, sep='\t')
            
            # Load mapping configuration
            mapping_path = self.config['app']['input']['mapping']
            with open(mapping_path, 'r', encoding='utf-8') as f:
                self.mapping = yaml.safe_load(f)
            
            # Load QC rules
            rules_path = self.config['app']['input']['qc_rules']
            self.qc_rules = pd.read_csv(rules_path, sep='\t')
            
            # Load QC tests
            tests_path = self.config['app']['input']['qc_tests']
            self.qc_tests = pd.read_csv(tests_path, sep='\t')
            
        except Exception as e:
            st.error(f"Error loading data: {e}")
            st.stop()

    def setup_page(self):
        """Set up the Streamlit page configuration."""
        st.set_page_config(
            page_title=self.config.get('title', 'uQCme Dashboard'),
            page_icon="🔬",
            layout="wide",
            initial_sidebar_state="expanded"
        )

    def render_header(self, filtered_data: pd.DataFrame):
        """Render the application header with filtered data statistics."""
        st.title("🔬 uQCme - Microbial Quality Control Dashboard")
        st.markdown(f"**Version:** {self.config.get('version', 'Unknown')}")
        
        # Add summary metrics based on filtered data
        col1, col2, col3, col4, col5 = st.columns(5)
        
        with col1:
            total_samples = len(filtered_data)
            total_all = len(self.data)
            st.metric("Samples", total_samples, delta=f"of {total_all}")
        
        with col2:
            pass_filter = filtered_data['qc_outcome'] == 'PASS'
            pass_count = len(filtered_data[pass_filter])
            st.metric("PASS", pass_count)
        
        with col3:
            fail_filter = filtered_data['qc_outcome'] != 'PASS'
            fail_count = len(filtered_data[fail_filter])
            st.metric("Issues Found", fail_count)
        
        with col4:
            unique_species = filtered_data['species'].nunique()
            st.metric("Unique Species", unique_species)
        
        with col5:
            column_count = len(filtered_data.columns)
            st.metric("Columns", column_count)

    def render_sidebar_filters(self):
        """Render sidebar filters for data exploration."""
        st.sidebar.header("🔍 Filters")
        
        # Species filter
        species_list = sorted(self.data['species'].unique().tolist())
        species_options = ['All'] + species_list
        selected_species = st.sidebar.selectbox(
            "Filter by Species",
            species_options,
            index=0
        )
        
        # QC outcome filter
        outcome_list = sorted(self.data['qc_outcome'].unique().tolist())
        outcome_options = ['All'] + outcome_list
        selected_outcome = st.sidebar.selectbox(
            "Filter by QC Outcome",
            outcome_options,
            index=0
        )
        
        # Sample name filter
        sample_filter = st.sidebar.text_input(
            "Search Sample Names",
            placeholder="Enter sample name..."
        )
        
        # Apply filters
        filtered_data = self.data.copy()
        
        if selected_species != 'All':
            condition = filtered_data['species'] == selected_species
            filtered_data = filtered_data[condition]
        
        if selected_outcome != 'All':
            condition = filtered_data['qc_outcome'] == selected_outcome
            filtered_data = filtered_data[condition]
        
        if sample_filter:
            contains_filter = filtered_data['sample_name'].str.contains(
                sample_filter, case=False, na=False
            )
            filtered_data = filtered_data[contains_filter]
        
        return filtered_data

    def _get_columns_by_section(self, data: pd.DataFrame) -> Dict[str, list]:
        """Get columns organized by section from mapping.yaml."""
        sections_columns = {}
        
        # Get sections from mapping
        sections = self.mapping.get('Sections', {})
        
        for section_name, section_data in sections.items():
            section_cols = []
            
            for field_name, field_config in section_data.items():
                # Skip if field_config is not a dict (e.g., boolean values)
                if not isinstance(field_config, dict):
                    continue
                    
                mapping_key = field_config.get('data', {}).get('mapping')
                if mapping_key and mapping_key in data.columns:
                    # Include hidden fields in the section but mark them
                    section_cols.append({
                        'column': mapping_key,
                        'field_name': field_name,
                        'hidden': field_config.get('hidden', False)
                    })
            
            if section_cols:  # Only add sections that have columns
                sections_columns[section_name] = section_cols
        
        # Add unmapped columns to "Other" section
        all_mapped_cols = []
        for section_cols in sections_columns.values():
            all_mapped_cols.extend([col['column'] for col in section_cols])
        
        unmapped_cols = [
            col for col in data.columns
            if col not in all_mapped_cols
        ]
        
        if unmapped_cols:
            sections_columns['Other'] = [
                {
                    'column': col,
                    'field_name': col.replace('_', ' ').title(),
                    'hidden': False
                }
                for col in unmapped_cols
            ]
        
        return sections_columns

    def _get_ordered_columns_with_sections(
        self,
        data: pd.DataFrame,
        visible_sections: Dict[str, bool]
    ) -> list:
        """Get ordered columns based on visible sections."""
        ordered_cols = []
        sections_columns = self._get_columns_by_section(data)
        
        # Define section order
        section_order = ['Basic', 'QC_metrics', 'Experimental', 'Other']
        
        # Add columns from visible sections in order
        for section_name in section_order:
            section_visible = visible_sections.get(section_name, True)
            if section_name in sections_columns and section_visible:
                for col_info in sections_columns[section_name]:
                    # For QC_metrics, respect hidden field settings
                    if section_name == 'QC_metrics' and col_info['hidden']:
                        qc_key_fields = ['qc_outcome', 'failed_rules']
                        if col_info['column'] not in qc_key_fields:
                            continue
                    ordered_cols.append(col_info['column'])
        
        # Add remaining sections not in the predefined order
        for section_name, section_cols in sections_columns.items():
            section_visible = visible_sections.get(section_name, True)
            section_not_ordered = section_name not in section_order
            if section_not_ordered and section_visible:
                for col_info in section_cols:
                    if col_info['column'] not in ordered_cols:
                        ordered_cols.append(col_info['column'])
        
        return ordered_cols

    def _get_qc_outcome_priority(self, outcome: str) -> int:
        """Get priority level for QC outcome."""
        # Define outcome priority mapping (higher number = higher priority)
        outcome_priorities = {
            'PASS': 1,
            'WARNING': 2,
            'FAIL': 3,
            'ERROR': 4
        }
        return outcome_priorities.get(outcome.upper(), 4)

    def _get_qc_outcome_color(self, outcome: str) -> str:
        """Get background color for QC outcome based on priority."""
        priority = self._get_qc_outcome_priority(outcome)
        priority_colors = self.config.get('priority_colors', {})
        
        # Map config colors to darker text-friendly colors
        color_mapping = {
            1: "#00AA00",  # Dark green for PASS
            2: "#FF8C00",  # Dark orange for WARNING
            3: "#DC143C",  # Dark red for FAIL
            4: "#8B0000"   # Dark red for ERROR
        }
        
        # Use config color if available, otherwise use our mapping
        config_color = priority_colors.get(priority)
        if config_color:
            return config_color
        else:
            return color_mapping.get(priority, "#000000")

    def render_data_preview_tab(self, filtered_data: pd.DataFrame):
        """Render the data preview tab with section toggles."""
        st.header("📊 Data Preview")
        
        sample_count = len(filtered_data)
        total_count = len(self.data)
        st.write(f"**Showing {sample_count} of {total_count} samples**")
        
        # Section toggles
        st.subheader("Section Visibility")
        sections_columns = self._get_columns_by_section(filtered_data)
        
        # Create columns for section toggles
        col1, col2, col3 = st.columns(3)
        
        visible_sections = {}
        section_names = list(sections_columns.keys())
        
        # Distribute toggles across columns
        for i, section_name in enumerate(section_names):
            col_idx = i % 3
            cols = [col1, col2, col3]
            
            with cols[col_idx]:
                # Count visible columns in section
                section_cols = sections_columns[section_name]
                visible_col_count = len([
                    col for col in section_cols
                    if not (section_name == 'QC_metrics' and
                            col['hidden'] and
                            col['column'] not in ['qc_outcome',
                                                  'failed_rules'])
                ])
                
                visible_sections[section_name] = st.checkbox(
                    f"{section_name} ({visible_col_count} columns)",
                    value=True,
                    key=f"data_preview_toggle_{section_name}"
                )
        
        # Get ordered columns based on visible sections
        ordered_columns = self._get_ordered_columns_with_sections(
            filtered_data,
            visible_sections
        )
        
        if not ordered_columns:
            st.warning("No columns selected. "
                       "Please enable at least one section.")
            return
        
        # Show active sections info
        active_sections = [
            name for name, visible in visible_sections.items()
            if visible
        ]
        
        # Display the dataframe with built-in controls and QC outcome styling
        # Use the full filtered data to ensure column controls are available
        if 'qc_outcome' in filtered_data.columns:
            
            # Apply color styling to highlight QC outcomes by priority
            def highlight_qc_outcome(val):
                if pd.isna(val):
                    return ''
                color = self._get_qc_outcome_color(str(val))
                # Use text color instead of background color
                return (f'color: {color}; font-weight: bold; '
                        f'text-shadow: 0 0 3px {color};')
            
            # Create styled dataframe - reorder columns first
            if ordered_columns:
                display_df = filtered_data[ordered_columns]
            else:
                display_df = filtered_data
            
            # Only apply styling if qc_outcome is in the display columns
            if 'qc_outcome' in display_df.columns:
                styled_df = display_df.style.map(
                    highlight_qc_outcome,
                    subset=['qc_outcome']
                )
                
                st.dataframe(
                    styled_df,
                    use_container_width=True,
                    key="data_preview_table"
                )
            else:
                warning_msg = ("QC Outcome column is not visible in current "
                               "selection. Enable QC_metrics section to see "
                               "colored outcomes.")
                st.warning(warning_msg)
                st.dataframe(
                    display_df,
                    use_container_width=True,
                    key="data_preview_table"
                )
        else:
            # No styling if qc_outcome column not present
            if ordered_columns:
                display_df = filtered_data[ordered_columns]
            else:
                display_df = filtered_data
                
            st.dataframe(
                display_df,
                use_container_width=True,
                key="data_preview_table"
            )
        
        # Show column information organized by visible sections
        with st.expander("📋 Column Information"):
            st.write("**Column mapping from configuration:**")
            
            for section_name in active_sections:
                if section_name in sections_columns:
                    st.subheader(f"{section_name} Section")
                    section_cols = sections_columns[section_name]
                    
                    for col_info in section_cols:
                        mapping_key = col_info['column']
                        field_name = col_info['field_name']
                        hidden = col_info['hidden']
                        
                        if mapping_key in filtered_data.columns:
                            # Skip truly hidden fields for QC_metrics
                            skip_hidden = (
                                section_name == 'QC_metrics' and
                                hidden and
                                mapping_key not in ['qc_outcome',
                                                    'failed_rules']
                            )
                            if skip_hidden:
                                continue
                                
                            hidden_status = " (Hidden)" if hidden else ""
                            field_display = (
                                f"- **{field_name}**: `{mapping_key}`"
                            )
                            st.write(f"{field_display}{hidden_status}")

    def render_overview_tab(self, filtered_data: pd.DataFrame):
        """Render the overview tab with summary statistics."""
        st.header("📈 Overview")
        
        # Use the plotter to create overview charts
        overview_plots = self.plotter.create_quality_overview_dashboard(
            filtered_data
        )
        
        # Display charts in columns
        col1, col2 = st.columns(2)
        
        with col1:
            st.subheader("QC Outcomes Distribution")
            if 'outcome_pie' in overview_plots:
                st.plotly_chart(
                    overview_plots['outcome_pie'],
                    use_container_width=True,
                    key="overview_outcome_pie"
                )
        
        with col2:
            st.subheader("Species Distribution")
            if 'species_bar' in overview_plots:
                st.plotly_chart(
                    overview_plots['species_bar'],
                    use_container_width=True,
                    key="overview_species_bar"
                )
        
        # Failed Rules Analysis
        st.subheader("Most Common Failed Rules")
        if 'failed_rules' in overview_plots:
            st.plotly_chart(
                overview_plots['failed_rules'],
                use_container_width=True,
                key="overview_failed_rules"
            )
        
        # Quality metrics if available
        if 'metric_dist' in overview_plots:
            st.subheader("Quality Metrics Distribution")
            st.plotly_chart(
                overview_plots['metric_dist'],
                use_container_width=True,
                key="overview_metric_dist"
            )
        
        if 'correlation' in overview_plots:
            st.subheader("Metrics Correlation")
            st.plotly_chart(
                overview_plots['correlation'],
                use_container_width=True,
                key="overview_correlation"
            )

    def render_quality_metrics_tab(self, filtered_data: pd.DataFrame):
        """Render quality metrics visualizations."""
        st.header("🔍 Quality Metrics")
        
        # Get available numeric columns
        available_cols = get_available_metrics(filtered_data)
        
        if not available_cols:
            warning_msg = (
                "No numeric quality metrics available for visualization."
            )
            st.warning(warning_msg)
            return
        
        # Metrics selection
        col1, col2 = st.columns(2)
        
        with col1:
            selected_metric = st.selectbox(
                "Select Quality Metric",
                available_cols,
                format_func=lambda x: self.plotter._format_column_name(x),
                index=0
            )
        
        with col2:
            chart_type = st.selectbox(
                "Chart Type",
                ["Distribution", "Box Plot", "Scatter Plot"],
                index=0
            )
        
        # Create visualizations using plotter
        if selected_metric and chart_type:
            if chart_type == "Distribution":
                fig = self.plotter.create_distribution_plot(
                    filtered_data, selected_metric
                )
                st.plotly_chart(
                    fig,
                    use_container_width=True,
                    key="metrics_distribution"
                )
                
            elif chart_type == "Box Plot":
                fig = self.plotter.create_box_plot(
                    filtered_data, selected_metric
                )
                st.plotly_chart(
                    fig,
                    use_container_width=True,
                    key="metrics_box_plot"
                )
                
            elif chart_type == "Scatter Plot":
                # Find another metric for comparison
                other_metrics = [
                    col for col in available_cols
                    if col != selected_metric
                ]
                
                if other_metrics:
                    def format_metric_name(x):
                        return self.plotter._format_column_name(x)
                    
                    y_metric = st.selectbox(
                        "Select Y-axis metric",
                        other_metrics,
                        format_func=format_metric_name,
                        index=0
                    )
                    
                    if y_metric:
                        fig = self.plotter.create_scatter_plot(
                            filtered_data, selected_metric, y_metric
                        )
                        st.plotly_chart(
                            fig,
                            use_container_width=True,
                            key="metrics_scatter_plot"
                        )
                else:
                    warning_msg = (
                        "No additional metrics available for scatter plot."
                    )
                    st.warning(warning_msg)

    def render_sample_details_tab(self, filtered_data: pd.DataFrame):
        """Render detailed sample information."""
        st.header("🔬 Sample Details")
        
        # Sample selection
        sample_options = filtered_data['sample_name'].tolist()
        
        if not sample_options:
            st.warning("No samples match the current filters.")
            return
        
        selected_sample = st.selectbox(
            "Select Sample",
            sample_options
        )
        
        # Get sample data
        selected_filter = filtered_data['sample_name'] == selected_sample
        sample_data = filtered_data[selected_filter].iloc[0]
        
        # Display sample information
        col1, col2 = st.columns(2)
        
        with col1:
            st.subheader("Basic Information")
            st.write(f"**Sample Name:** {sample_data['sample_name']}")
            st.write(f"**Species:** {sample_data['species']}")
            provided_spec = sample_data.get('provided_species', 'N/A')
            st.write(f"**Provided Species:** {provided_spec}")
            st.write(f"**QC Outcome:** {sample_data['qc_outcome']}")
        
        with col2:
            st.subheader("Quality Metrics")
            if 'GC' in sample_data:
                st.write(f"**GC Content:** {sample_data['GC']:.2f}%")
            if 'N50' in sample_data:
                st.write(f"**N50:** {sample_data['N50']:,.0f}")
            if 'bin_length_at_1x' in sample_data:
                genome_size = sample_data['bin_length_at_1x']
                st.write(f"**Genome Size:** {genome_size:,.0f} bp")
        
        # Failed and passed rules
        st.subheader("QC Rules Analysis")
        
        col1, col2 = st.columns(2)
        
        with col1:
            if sample_data.get('failed_rules'):
                st.write("**Failed Rules:**")
                failed_rules = sample_data['failed_rules'].split(',')
                for rule in failed_rules:
                    st.write(f"❌ {rule.strip()}")
            else:
                st.write("✅ No failed rules")
        
        with col2:
            if sample_data.get('passed_rules'):
                st.write("**Passed Rules:**")
                passed_rules = sample_data['passed_rules'].split(',')
                for rule in passed_rules[:10]:  # Show first 10
                    st.write(f"✅ {rule.strip()}")
                if len(passed_rules) > 10:
                    st.write(f"... and {len(passed_rules) - 10} more")

    def run(self):
        """Run the Streamlit application."""
        # Setup page
        self.setup_page()
        
        # Load data
        self.load_data()
        
        # Get filtered data
        filtered_data = self.render_sidebar_filters()
        
        # Render header with filtered data
        self.render_header(filtered_data)
        
        # Main content tabs
        tabs = st.tabs([
            "📊 Data Preview",
            "📈 Overview",
            "🔍 Quality Metrics",
            "🔬 Sample Details"
        ])
        
        with tabs[0]:
            self.render_data_preview_tab(filtered_data)
        
        with tabs[1]:
            self.render_overview_tab(filtered_data)
        
        with tabs[2]:
            self.render_quality_metrics_tab(filtered_data)
        
        with tabs[3]:
            self.render_sample_details_tab(filtered_data)


def main():
    """Main entry point for the Streamlit app."""
    # Configuration file path
    config_path = "config.yaml"
    
    # Check if config file exists
    if not Path(config_path).exists():
        st.error(f"Configuration file '{config_path}' not found!")
        st.stop()
    
    # Initialize and run dashboard
    dashboard = QCDashboard(config_path)
    dashboard.run()


if __name__ == "__main__":
    main()
